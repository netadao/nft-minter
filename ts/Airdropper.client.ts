/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Addr, CheckAddressPromisedMintsResponse, CheckAddressPromisedTokensResponse, TokenMsg, Timestamp, Uint64, Config, ExecuteMsg, InstantiateMsg, AddressTokenMsg, AddressValMsg, GetAddressPromisedMintsResponse, GetAddressPromisedTokenIDsResponse, AddressPromisedTokensResponse, GetAssignedTokenIDsResponse, GetAssignedTokenIDsWithAddressResponse, GetClaimedAddressPromisedMintsResponse, GetClaimedTokenIDsResponse, GetClaimedTokenIDsWithAddressResponse, GetConfigResponse, QueryMsg } from "./Airdropper.types";
export interface AirdropperReadOnlyInterface {
  contractAddress: string;
  getConfig: () => Promise<GetConfigResponse>;
  getAddressPromisedTokenIds: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetAddressPromisedTokenIdsResponse>;
  getAssignedTokenIds: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetAssignedTokenIdsResponse>;
  getAssignedTokenIdsWithAddress: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetAssignedTokenIdsWithAddressResponse>;
  getClaimedTokenIds: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetClaimedTokenIdsResponse>;
  getClaimedTokenIdsWithAddress: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetClaimedTokenIdsWithAddressResponse>;
  getAddressPromisedMints: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetAddressPromisedMintsResponse>;
  getClaimedAddressPromisedMints: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetClaimedAddressPromisedMintsResponse>;
  checkAddressPromisedMints: ({
    minterAddress
  }: {
    minterAddress: string;
  }) => Promise<CheckAddressPromisedMintsResponse>;
  checkAddressPromisedTokens: ({
    minterAddress
  }: {
    minterAddress: string;
  }) => Promise<CheckAddressPromisedTokensResponse>;
}
export class AirdropperQueryClient implements AirdropperReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getConfig = this.getConfig.bind(this);
    this.getAddressPromisedTokenIds = this.getAddressPromisedTokenIds.bind(this);
    this.getAssignedTokenIds = this.getAssignedTokenIds.bind(this);
    this.getAssignedTokenIdsWithAddress = this.getAssignedTokenIdsWithAddress.bind(this);
    this.getClaimedTokenIds = this.getClaimedTokenIds.bind(this);
    this.getClaimedTokenIdsWithAddress = this.getClaimedTokenIdsWithAddress.bind(this);
    this.getAddressPromisedMints = this.getAddressPromisedMints.bind(this);
    this.getClaimedAddressPromisedMints = this.getClaimedAddressPromisedMints.bind(this);
    this.checkAddressPromisedMints = this.checkAddressPromisedMints.bind(this);
    this.checkAddressPromisedTokens = this.checkAddressPromisedTokens.bind(this);
  }

  getConfig = async (): Promise<GetConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_config: {}
    });
  };
  getAddressPromisedTokenIds = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetAddressPromisedTokenIdsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_address_promised_token_ids: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAssignedTokenIds = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetAssignedTokenIdsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_assigned_token_ids: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAssignedTokenIdsWithAddress = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetAssignedTokenIdsWithAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_assigned_token_ids_with_address: {
        limit,
        start_after: startAfter
      }
    });
  };
  getClaimedTokenIds = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetClaimedTokenIdsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claimed_token_ids: {
        limit,
        start_after: startAfter
      }
    });
  };
  getClaimedTokenIdsWithAddress = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetClaimedTokenIdsWithAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claimed_token_ids_with_address: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAddressPromisedMints = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetAddressPromisedMintsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_address_promised_mints: {
        limit,
        start_after: startAfter
      }
    });
  };
  getClaimedAddressPromisedMints = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetClaimedAddressPromisedMintsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claimed_address_promised_mints: {
        limit,
        start_after: startAfter
      }
    });
  };
  checkAddressPromisedMints = async ({
    minterAddress
  }: {
    minterAddress: string;
  }): Promise<CheckAddressPromisedMintsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      check_address_promised_mints: {
        minter_address: minterAddress
      }
    });
  };
  checkAddressPromisedTokens = async ({
    minterAddress
  }: {
    minterAddress: string;
  }): Promise<CheckAddressPromisedTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      check_address_promised_tokens: {
        minter_address: minterAddress
      }
    });
  };
}
export interface AirdropperInterface extends AirdropperReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    endTime,
    maintainerAddress,
    startTime
  }: {
    endTime?: Timestamp;
    maintainerAddress?: string;
    startTime: Timestamp;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateMaintainerAddress: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addPromisedTokenIds: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removePromisedTokenIds: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removePromisedTokensByAddress: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addPromisedMints: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removePromisedMints: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  markTokenIdClaimed: ({
    address,
    token
  }: {
    address: string;
    token: TokenMsg;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  incrementAddressClaimedPromisedMintCount: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class AirdropperClient extends AirdropperQueryClient implements AirdropperInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.updateMaintainerAddress = this.updateMaintainerAddress.bind(this);
    this.addPromisedTokenIds = this.addPromisedTokenIds.bind(this);
    this.removePromisedTokenIds = this.removePromisedTokenIds.bind(this);
    this.removePromisedTokensByAddress = this.removePromisedTokensByAddress.bind(this);
    this.addPromisedMints = this.addPromisedMints.bind(this);
    this.removePromisedMints = this.removePromisedMints.bind(this);
    this.markTokenIdClaimed = this.markTokenIdClaimed.bind(this);
    this.incrementAddressClaimedPromisedMintCount = this.incrementAddressClaimedPromisedMintCount.bind(this);
  }

  updateConfig = async ({
    endTime,
    maintainerAddress,
    startTime
  }: {
    endTime?: Timestamp;
    maintainerAddress?: string;
    startTime: Timestamp;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        end_time: endTime,
        maintainer_address: maintainerAddress,
        start_time: startTime
      }
    }, fee, memo, funds);
  };
  updateMaintainerAddress = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_maintainer_address: {}
    }, fee, memo, funds);
  };
  addPromisedTokenIds = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_promised_token_ids: {}
    }, fee, memo, funds);
  };
  removePromisedTokenIds = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_promised_token_ids: {}
    }, fee, memo, funds);
  };
  removePromisedTokensByAddress = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_promised_tokens_by_address: {}
    }, fee, memo, funds);
  };
  addPromisedMints = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_promised_mints: {}
    }, fee, memo, funds);
  };
  removePromisedMints = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_promised_mints: {}
    }, fee, memo, funds);
  };
  markTokenIdClaimed = async ({
    address,
    token
  }: {
    address: string;
    token: TokenMsg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mark_token_id_claimed: {
        address,
        token
      }
    }, fee, memo, funds);
  };
  incrementAddressClaimedPromisedMintCount = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      increment_address_claimed_promised_mint_count: {}
    }, fee, memo, funds);
  };
}