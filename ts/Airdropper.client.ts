/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Addr, CheckAddressPromisedMintsResponse, CheckAddressPromisedTokensResponse, TokenMsg, Timestamp, Uint64, Config, ExecuteMsg, InstantiateMsg, AddressTokenMsg, AddressValMsg, GetAddressPromisedMintsResponse, GetAddressPromisedTokenIDsResponse, AddressPromisedTokensResponse, GetAssignedTokenIDsResponse, GetAssignedTokenIDsWithAddressResponse, GetClaimedAddressPromisedMintsResponse, GetClaimedTokenIDsResponse, GetClaimedTokenIDsWithAddressResponse, GetConfigResponse, QueryMsg } from "./Airdropper.types";
export interface AirdropperReadOnlyInterface {
  contractAddress: string;
  getConfig: () => Promise<GetConfigResponse>;
  getAddressPromisedTokenIDs: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetAddressPromisedTokenIDsResponse>;
  getAssignedTokenIDs: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetAssignedTokenIDsResponse>;
  getAssignedTokenIDsWithAddress: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetAssignedTokenIDsWithAddressResponse>;
  getClaimedTokenIDs: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetClaimedTokenIDsResponse>;
  getClaimedTokenIDsWithAddress: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<GetClaimedTokenIDsWithAddressResponse>;
  getAddressPromisedMints: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetAddressPromisedMintsResponse>;
  getClaimedAddressPromisedMints: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetClaimedAddressPromisedMintsResponse>;
  checkAddressPromisedMints: ({
    minterAddress
  }: {
    minterAddress: string;
  }) => Promise<CheckAddressPromisedMintsResponse>;
  checkAddressPromisedTokens: ({
    minterAddress
  }: {
    minterAddress: string;
  }) => Promise<CheckAddressPromisedTokensResponse>;
}
export class AirdropperQueryClient implements AirdropperReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getConfig = this.getConfig.bind(this);
    this.getAddressPromisedTokenIDs = this.getAddressPromisedTokenIDs.bind(this);
    this.getAssignedTokenIDs = this.getAssignedTokenIDs.bind(this);
    this.getAssignedTokenIDsWithAddress = this.getAssignedTokenIDsWithAddress.bind(this);
    this.getClaimedTokenIDs = this.getClaimedTokenIDs.bind(this);
    this.getClaimedTokenIDsWithAddress = this.getClaimedTokenIDsWithAddress.bind(this);
    this.getAddressPromisedMints = this.getAddressPromisedMints.bind(this);
    this.getClaimedAddressPromisedMints = this.getClaimedAddressPromisedMints.bind(this);
    this.checkAddressPromisedMints = this.checkAddressPromisedMints.bind(this);
    this.checkAddressPromisedTokens = this.checkAddressPromisedTokens.bind(this);
  }

  getConfig = async (): Promise<GetConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_config: {}
    });
  };
  getAddressPromisedTokenIDs = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetAddressPromisedTokenIDsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_address_promised_token_i_ds: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAssignedTokenIDs = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetAssignedTokenIDsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_assigned_token_i_ds: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAssignedTokenIDsWithAddress = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetAssignedTokenIDsWithAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_assigned_token_i_ds_with_address: {
        limit,
        start_after: startAfter
      }
    });
  };
  getClaimedTokenIDs = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetClaimedTokenIDsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claimed_token_i_ds: {
        limit,
        start_after: startAfter
      }
    });
  };
  getClaimedTokenIDsWithAddress = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<GetClaimedTokenIDsWithAddressResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claimed_token_i_ds_with_address: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAddressPromisedMints = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetAddressPromisedMintsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_address_promised_mints: {
        limit,
        start_after: startAfter
      }
    });
  };
  getClaimedAddressPromisedMints = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetClaimedAddressPromisedMintsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claimed_address_promised_mints: {
        limit,
        start_after: startAfter
      }
    });
  };
  checkAddressPromisedMints = async ({
    minterAddress
  }: {
    minterAddress: string;
  }): Promise<CheckAddressPromisedMintsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      check_address_promised_mints: {
        minter_address: minterAddress
      }
    });
  };
  checkAddressPromisedTokens = async ({
    minterAddress
  }: {
    minterAddress: string;
  }): Promise<CheckAddressPromisedTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      check_address_promised_tokens: {
        minter_address: minterAddress
      }
    });
  };
}
export interface AirdropperInterface extends AirdropperReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    endTime,
    maintainerAddress,
    startTime
  }: {
    endTime?: Timestamp;
    maintainerAddress?: string;
    startTime: Timestamp;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateMaintainerAddress: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addPromisedTokenIDs: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removePromisedTokenIDs: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removePromisedTokensByAddress: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addPromisedMints: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removePromisedMints: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  markTokenIDClaimed: ({
    address,
    token
  }: {
    address: string;
    token: TokenMsg;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  incrementAddressClaimedPromisedMintCount: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class AirdropperClient extends AirdropperQueryClient implements AirdropperInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.updateMaintainerAddress = this.updateMaintainerAddress.bind(this);
    this.addPromisedTokenIDs = this.addPromisedTokenIDs.bind(this);
    this.removePromisedTokenIDs = this.removePromisedTokenIDs.bind(this);
    this.removePromisedTokensByAddress = this.removePromisedTokensByAddress.bind(this);
    this.addPromisedMints = this.addPromisedMints.bind(this);
    this.removePromisedMints = this.removePromisedMints.bind(this);
    this.markTokenIDClaimed = this.markTokenIDClaimed.bind(this);
    this.incrementAddressClaimedPromisedMintCount = this.incrementAddressClaimedPromisedMintCount.bind(this);
  }

  updateConfig = async ({
    endTime,
    maintainerAddress,
    startTime
  }: {
    endTime?: Timestamp;
    maintainerAddress?: string;
    startTime: Timestamp;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        end_time: endTime,
        maintainer_address: maintainerAddress,
        start_time: startTime
      }
    }, fee, memo, funds);
  };
  updateMaintainerAddress = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_maintainer_address: {}
    }, fee, memo, funds);
  };
  addPromisedTokenIDs = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_promised_token_i_ds: {}
    }, fee, memo, funds);
  };
  removePromisedTokenIDs = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_promised_token_i_ds: {}
    }, fee, memo, funds);
  };
  removePromisedTokensByAddress = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_promised_tokens_by_address: {}
    }, fee, memo, funds);
  };
  addPromisedMints = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_promised_mints: {}
    }, fee, memo, funds);
  };
  removePromisedMints = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_promised_mints: {}
    }, fee, memo, funds);
  };
  markTokenIDClaimed = async ({
    address,
    token
  }: {
    address: string;
    token: TokenMsg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mark_token_i_d_claimed: {
        address,
        token
      }
    }, fee, memo, funds);
  };
  incrementAddressClaimedPromisedMintCount = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      increment_address_claimed_promised_mint_count: {}
    }, fee, memo, funds);
  };
}