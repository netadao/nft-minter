/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.20.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint128, Addr, CheckWhitelistResponse, Timestamp, Uint64, Config, ExecuteMsg, InstantiateMsg, GetAddressMintsResponse, GetConfigResponse, GetWhitelistAddressesResponse, QueryMsg } from "./Whitelist.types";
export interface WhitelistReadOnlyInterface {
  contractAddress: string;
  getConfig: () => Promise<GetConfigResponse>;
  checkWhitelist: ({
    minterAddress
  }: {
    minterAddress: string;
  }) => Promise<CheckWhitelistResponse>;
  getWhitelistAddresses: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetWhitelistAddressesResponse>;
  getAddressMints: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<GetAddressMintsResponse>;
}
export class WhitelistQueryClient implements WhitelistReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getConfig = this.getConfig.bind(this);
    this.checkWhitelist = this.checkWhitelist.bind(this);
    this.getWhitelistAddresses = this.getWhitelistAddresses.bind(this);
    this.getAddressMints = this.getAddressMints.bind(this);
  }

  getConfig = async (): Promise<GetConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_config: {}
    });
  };
  checkWhitelist = async ({
    minterAddress
  }: {
    minterAddress: string;
  }): Promise<CheckWhitelistResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      check_whitelist: {
        minter_address: minterAddress
      }
    });
  };
  getWhitelistAddresses = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetWhitelistAddressesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_whitelist_addresses: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAddressMints = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<GetAddressMintsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_address_mints: {
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface WhitelistInterface extends WhitelistReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    endTime,
    maintainerAddress,
    maxPerAddressMint,
    maxWhitelistAddressCount,
    mintPrice,
    startTime
  }: {
    endTime: Timestamp;
    maintainerAddress?: string;
    maxPerAddressMint: number;
    maxWhitelistAddressCount: number;
    mintPrice: Uint128;
    startTime: Timestamp;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateMaintainerAddress: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addToWhitelist: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removeFromWhitelist: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateAddressMintTracker: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class WhitelistClient extends WhitelistQueryClient implements WhitelistInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.updateMaintainerAddress = this.updateMaintainerAddress.bind(this);
    this.addToWhitelist = this.addToWhitelist.bind(this);
    this.removeFromWhitelist = this.removeFromWhitelist.bind(this);
    this.updateAddressMintTracker = this.updateAddressMintTracker.bind(this);
  }

  updateConfig = async ({
    endTime,
    maintainerAddress,
    maxPerAddressMint,
    maxWhitelistAddressCount,
    mintPrice,
    startTime
  }: {
    endTime: Timestamp;
    maintainerAddress?: string;
    maxPerAddressMint: number;
    maxWhitelistAddressCount: number;
    mintPrice: Uint128;
    startTime: Timestamp;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        end_time: endTime,
        maintainer_address: maintainerAddress,
        max_per_address_mint: maxPerAddressMint,
        max_whitelist_address_count: maxWhitelistAddressCount,
        mint_price: mintPrice,
        start_time: startTime
      }
    }, fee, memo, funds);
  };
  updateMaintainerAddress = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_maintainer_address: {}
    }, fee, memo, funds);
  };
  addToWhitelist = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_to_whitelist: {}
    }, fee, memo, funds);
  };
  removeFromWhitelist = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_from_whitelist: {}
    }, fee, memo, funds);
  };
  updateAddressMintTracker = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_address_mint_tracker: {}
    }, fee, memo, funds);
  };
}